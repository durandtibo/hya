{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>hya</code> is a library of custom OmegaConf resolvers designed to be used with Hydra. It provides a comprehensive set of resolvers for mathematical operations, path manipulation, data type conversions, and more.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The default resolvers are automatically registered when you import <code>hya</code>:</p> <pre><code>import hya\nfrom omegaconf import OmegaConf\n\n# Use resolvers in your configuration\nconf = OmegaConf.create(\n    {\n        \"batch_size\": 32,\n        \"num_samples\": 1000,\n        \"num_batches\": \"${hya.ceildiv:${num_samples},${batch_size}}\",\n        \"learning_rate\": \"${hya.pow:10,-3}\",  # 0.001\n    }\n)\n\nprint(conf.num_batches)  # Output: 32\nprint(conf.learning_rate)  # Output: 0.001\n</code></pre>"},{"location":"#using-with-hydra","title":"Using with Hydra","text":"<p>Create a configuration file <code>config.yaml</code>:</p> <pre><code>model:\n  input_dim: 784\n  hidden_dim: 256\n  output_dim: 10\n\ntraining:\n  batch_size: 32\n  num_epochs: 10\n  learning_rate: ${hya.pow:10,-3}  # 0.001\n\npaths:\n  data_dir: ${hya.path:/data}\n  model_dir: ${hya.iter_join:[${paths.data_dir},models,v1],/}\n\nexperiment:\n  name: mnist_classifier\n  id: ${hya.sha256:${experiment.name}}\n</code></pre> <p>Then use it in your Python script:</p> <pre><code>import hya\nimport hydra\nfrom omegaconf import DictConfig\n\n\n@hydra.main(version_base=None, config_path=\".\", config_name=\"config\")\ndef main(cfg: DictConfig):\n    print(f\"Learning rate: {cfg.training.learning_rate}\")\n    print(f\"Model dir: {cfg.paths.model_dir}\")\n    print(f\"Experiment ID: {cfg.experiment.id}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"#registering-custom-resolvers","title":"Registering Custom Resolvers","text":"<p>You can extend <code>hya</code> with your own custom resolvers:</p> <pre><code>from hya import get_default_registry\n\nregistry = get_default_registry()\n\n\n@registry.register(\"multiply\")\ndef multiply_resolver(x, y):\n    return x * y\n\n\n# Register the custom resolver with OmegaConf\nregistry.register_resolvers()\n\n# Now use it in your configuration\nconf = OmegaConf.create({\"result\": \"${multiply:5,3}\"})\nprint(conf.result)  # Output: 15\n</code></pre>"},{"location":"#available-resolvers","title":"Available Resolvers","text":"<p><code>hya</code> provides over 20 built-in resolvers organized into categories:</p> <ul> <li>Mathematical operations: <code>add</code>, <code>sub</code>, <code>mul</code>, <code>truediv</code>, <code>floordiv</code>, <code>ceildiv</code>, <code>pow</code>, <code>sqrt</code>, <code>neg</code>, <code>max</code>, <code>min</code>, <code>exp</code>, <code>log</code>, <code>log10</code>, <code>sinh</code>, <code>asinh</code></li> <li>Constants: <code>pi</code></li> <li>Path utilities: <code>path</code>, <code>to_path</code>, <code>iter_join</code></li> <li>Utilities: <code>len</code>, <code>sha256</code></li> <li>Optional (with dependencies):</li> <li>NumPy: <code>np.array</code></li> <li>PyTorch: <code>torch.tensor</code>, <code>torch.dtype</code></li> <li>Braceexpand: <code>braceexpand</code></li> </ul> <p>See the Resolvers page for complete documentation of all resolvers.</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>hya</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>hya</code> to a new version will possibly break any code that was using the old version of <code>hya</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>hya</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-uv-recommended","title":"Installing with <code>uv</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>uv pip install hya\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>hya</code> are installed. This minimal installation includes only <code>omegaconf</code>, which is sufficient for using all the core resolvers.</p>"},{"location":"get_started/#installing-optional-dependencies","title":"Installing Optional Dependencies","text":"<p><code>hya</code> provides additional resolvers that require optional dependencies:</p> <pre><code># Install all optional dependencies\nuv pip install 'hya[all]'\n\n# Install specific optional dependencies\nuv pip install hya braceexpand  # For hya.braceexpand resolver\nuv pip install hya numpy        # For hya.np.array resolver\nuv pip install hya torch        # For hya.torch.tensor and hya.torch.dtype resolvers\n</code></pre>"},{"location":"get_started/#dependency-matrix","title":"Dependency Matrix","text":"<p>The following table shows which resolvers require which packages:</p> Resolver Required Package Description <code>hya.braceexpand</code> <code>braceexpand&gt;=0.1.7</code> Brace expansion patterns <code>hya.np.array</code> <code>numpy&gt;=1.24</code> NumPy array creation <code>hya.torch.tensor</code> <code>torch&gt;=2.0</code> PyTorch tensor creation <code>hya.torch.dtype</code> <code>torch&gt;=2.0</code> PyTorch data type specification <p>All other resolvers work with the base installation (only <code>omegaconf</code> required).</p> <p>If you try to use a resolver that requires an optional package without installing it, you'll receive a helpful error message indicating which package needs to be installed.</p>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>hya</code> from source, you can follow the steps below. First, you will need to install <code>uv</code>. <code>uv</code> is used to manage and install the dependencies. If <code>uv</code> is already installed on your machine, you can skip this step. You can check the <code>uv</code> installation by running the following command:</p> <pre><code>uv --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/hya.git\n</code></pre> <p>It is recommended to create a Python 3.10+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate hya\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>hya</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"resolvers/","title":"Resolvers","text":"<p> This page provides comprehensive documentation for all resolvers implemented in <code>hya</code>.</p>"},{"location":"resolvers/#overview","title":"Overview","text":"<p><code>hya</code> provides over 20 built-in resolvers for use in OmegaConf/Hydra configurations. Resolvers are organized into the following categories:</p> <ul> <li>Arithmetic Operations: Basic mathematical operations (add, subtract, multiply, divide)</li> <li>Advanced Math: Transcendental and special functions (exp, log, sqrt, powers)</li> <li>Comparison: Min/max operations</li> <li>Path Utilities: Path creation and manipulation</li> <li>String Utilities: Joining and hashing</li> <li>Utility Functions: Length, negation, constants</li> <li>Optional Resolvers: Require additional packages (NumPy, PyTorch, braceexpand)</li> </ul> <p>All resolvers are automatically available after importing <code>hya</code>.</p>"},{"location":"resolvers/#default-resolvers","title":"Default Resolvers","text":"<p>These resolvers are available with the base installation (no optional dependencies required).</p>"},{"location":"resolvers/#arithmetic-operations","title":"Arithmetic Operations","text":""},{"location":"resolvers/#hyaadd","title":"<code>hya.add</code>","text":"<p>Adds multiple values together.</p> <p>Syntax: <code>${hya.add:value1,value2,...}</code></p> <p>Example: <pre><code># Simple addition\ntotal: ${hya.add:10,20}  # Result: 30\n\n# Multiple values\nsum: ${hya.add:1,2,3,4,5}  # Result: 15\n\n# With references\ntraining:\n  train_samples: 50000\n  val_samples: 10000\n  total_samples: ${hya.add:${training.train_samples},${training.val_samples}}  # Result: 60000\n</code></pre></p> <p>Equivalent Python: <pre><code>value = value1 + value2 + value3 + ...\n</code></pre></p>"},{"location":"resolvers/#hyasub","title":"<code>hya.sub</code>","text":"<p>Subtracts the second value from the first.</p> <p>Syntax: <code>${hya.sub:value1,value2}</code></p> <p>Example: <pre><code>remaining: ${hya.sub:100,30}  # Result: 70\n\ndataset:\n  total_samples: 60000\n  val_samples: 10000\n  train_samples: ${hya.sub:${dataset.total_samples},${dataset.val_samples}}  # Result: 50000\n</code></pre></p> <p>Equivalent Python: <pre><code>value = object1 - object2\n</code></pre></p>"},{"location":"resolvers/#hyamul","title":"<code>hya.mul</code>","text":"<p>Multiplies multiple values together.</p> <p>Syntax: <code>${hya.mul:value1,value2,...}</code></p> <p>Example: <pre><code># Simple multiplication\narea: ${hya.mul:10,20}  # Result: 200\n\n# Multiple values\nvolume: ${hya.mul:5,10,2}  # Result: 100\n\n# Compute total parameters\nmodel:\n  layers: 12\n  hidden_size: 768\n  total_params: ${hya.mul:${model.layers},${model.hidden_size}}  # Result: 9216\n</code></pre></p> <p>Equivalent Python: <pre><code>value = object1 * object2 * object3 * ...\n</code></pre></p>"},{"location":"resolvers/#hyatruediv","title":"<code>hya.truediv</code>","text":"<p>Performs \"true\" division (floating-point division).</p> <p>Syntax: <code>${hya.truediv:dividend,divisor}</code></p> <p>Example: <pre><code>ratio: ${hya.truediv:10,4}  # Result: 2.5\n\ntraining:\n  total_steps: 10000\n  warmup_ratio: ${hya.truediv:1000,${training.total_steps}}  # Result: 0.1\n</code></pre></p> <p>Equivalent Python: <pre><code>value = dividend / divisor\n</code></pre></p>"},{"location":"resolvers/#hyafloordiv","title":"<code>hya.floordiv</code>","text":"<p>Performs floor division (rounds down to nearest integer).</p> <p>Syntax: <code>${hya.floordiv:dividend,divisor}</code></p> <p>Example: <pre><code>batches: ${hya.floordiv:100,32}  # Result: 3\n\n# Complete batches only\ntraining:\n  samples: 10000\n  batch_size: 64\n  complete_batches: ${hya.floordiv:${training.samples},${training.batch_size}}  # Result: 156\n</code></pre></p> <p>Equivalent Python: <pre><code>value = dividend // divisor\n</code></pre></p>"},{"location":"resolvers/#hyaceildiv","title":"<code>hya.ceildiv</code>","text":"<p>Performs ceiling division (rounds up to nearest integer).</p> <p>Syntax: <code>${hya.ceildiv:dividend,divisor}</code></p> <p>Example: <pre><code>batches: ${hya.ceildiv:100,32}  # Result: 4\n\n# Calculate number of batches needed\ntraining:\n  samples: 10000\n  batch_size: 64\n  num_batches: ${hya.ceildiv:${training.samples},${training.batch_size}}  # Result: 157\n</code></pre></p> <p>Equivalent Python: <pre><code>value = -(dividend // -divisor)  # Canonical implementation (no floating point)\n# Alternative (but may have precision issues with large integers):\n# value = math.ceil(dividend / divisor)\n</code></pre></p> <p>Use Case: Calculating the number of batches needed to process all samples.</p>"},{"location":"resolvers/#advanced-mathematical-functions","title":"Advanced Mathematical Functions","text":""},{"location":"resolvers/#hyapow","title":"<code>hya.pow</code>","text":"<p>Raises a value to a given power.</p> <p>Syntax: <code>${hya.pow:base,exponent}</code></p> <p>Example: <pre><code>squared: ${hya.pow:5,2}  # Result: 25\ncubed: ${hya.pow:2,3}  # Result: 8\n\n# Scientific notation for learning rates\ntraining:\n  lr: ${hya.pow:10,-3}  # Result: 0.001\n  weight_decay: ${hya.pow:10,-4}  # Result: 0.0001\n</code></pre></p> <p>Equivalent Python: <pre><code>value = base**exponent\n</code></pre></p>"},{"location":"resolvers/#hyasqrt","title":"<code>hya.sqrt</code>","text":"<p>Computes the square root of a number.</p> <p>Syntax: <code>${hya.sqrt:number}</code></p> <p>Example: <pre><code>side: ${hya.sqrt:64}  # Result: 8.0\n\nmodel:\n  embedding_dim: 512\n  scale_factor: ${hya.sqrt:${model.embedding_dim}}  # Result: 22.627...\n</code></pre></p> <p>Equivalent Python: <pre><code>import math\n\nvalue = math.sqrt(number)\n</code></pre></p>"},{"location":"resolvers/#hyaexp","title":"<code>hya.exp</code>","text":"<p>Computes the exponential (e^x).</p> <p>Syntax: <code>${hya.exp:number}</code></p> <p>Example: <pre><code>exponential: ${hya.exp:0}  # Result: 1.0\ngrowth: ${hya.exp:1}  # Result: 2.718...\n</code></pre></p> <p>Equivalent Python: <pre><code>import math\n\nvalue = math.exp(number)\n</code></pre></p>"},{"location":"resolvers/#hyalog","title":"<code>hya.log</code>","text":"<p>Computes the logarithm with a given base (default: natural log).</p> <p>Syntax: <code>${hya.log:number,base}</code> or <code>${hya.log:number}</code> (base e)</p> <p>Example: <pre><code>natural_log: ${hya.log:10}  # Result: 2.302... (ln(10))\nlog_base_2: ${hya.log:8,2}  # Result: 3.0 (log2(8))\nlog_base_10: ${hya.log:1000,10}  # Result: 3.0\n</code></pre></p> <p>Equivalent Python: <pre><code>import math\n\nvalue = math.log(number, base)  # or math.log(number) for natural log\n</code></pre></p>"},{"location":"resolvers/#hyalog10","title":"<code>hya.log10</code>","text":"<p>Computes the base-10 logarithm.</p> <p>Syntax: <code>${hya.log10:number}</code></p> <p>Example: <pre><code>log_value: ${hya.log10:100}  # Result: 2.0\ndecades: ${hya.log10:1000}  # Result: 3.0\n</code></pre></p> <p>Equivalent Python: <pre><code>import math\n\nvalue = math.log10(number)\n</code></pre></p>"},{"location":"resolvers/#hyasinh","title":"<code>hya.sinh</code>","text":"<p>Computes the hyperbolic sine.</p> <p>Syntax: <code>${hya.sinh:number}</code></p> <p>Example: <pre><code>result: ${hya.sinh:1}  # Result: 1.175...\n</code></pre></p> <p>Equivalent Python: <pre><code>import math\n\nvalue = math.sinh(number)\n</code></pre></p>"},{"location":"resolvers/#hyaasinh","title":"<code>hya.asinh</code>","text":"<p>Computes the inverse hyperbolic sine.</p> <p>Syntax: <code>${hya.asinh:number}</code></p> <p>Example: <pre><code>result: ${hya.asinh:1}  # Result: 0.881...\n</code></pre></p> <p>Equivalent Python: <pre><code>import math\n\nvalue = math.asinh(number)\n</code></pre></p>"},{"location":"resolvers/#hyaneg","title":"<code>hya.neg</code>","text":"<p>Returns the negation of a number.</p> <p>Syntax: <code>${hya.neg:number}</code></p> <p>Example: <pre><code>negative: ${hya.neg:5}  # Result: -5\nflipped: ${hya.neg:-10}  # Result: 10\n</code></pre></p> <p>Equivalent Python: <pre><code>value = -number\n</code></pre></p>"},{"location":"resolvers/#comparison-functions","title":"Comparison Functions","text":""},{"location":"resolvers/#hyamax","title":"<code>hya.max</code>","text":"<p>Returns the maximum value among multiple inputs.</p> <p>Syntax: <code>${hya.max:value1,value2,...}</code></p> <p>Example: <pre><code>maximum: ${hya.max:10,25,15}  # Result: 25\n\nmodel:\n  min_layers: 4\n  default_layers: 8\n  requested_layers: 2\n  actual_layers: ${hya.max:${model.requested_layers},${model.min_layers}}  # Result: 4 (enforces minimum)\n</code></pre></p> <p>Equivalent Python: <pre><code>value = max(value1, value2, value3, ...)\n</code></pre></p>"},{"location":"resolvers/#hyamin","title":"<code>hya.min</code>","text":"<p>Returns the minimum value among multiple inputs.</p> <p>Syntax: <code>${hya.min:value1,value2,...}</code></p> <p>Example: <pre><code>minimum: ${hya.min:10,25,15}  # Result: 10\n\ntraining:\n  requested_lr: 0.1\n  max_lr: 0.01\n  actual_lr: ${hya.min:${training.requested_lr},${training.max_lr}}  # Result: 0.01\n</code></pre></p> <p>Equivalent Python: <pre><code>value = min(value1, value2, value3, ...)\n</code></pre></p>"},{"location":"resolvers/#constants","title":"Constants","text":""},{"location":"resolvers/#hyapi","title":"<code>hya.pi</code>","text":"<p>Returns the mathematical constant \u03c0 (pi).</p> <p>Syntax: <code>${hya.pi:}</code></p> <p>Example: <pre><code>pi_value: ${hya.pi:}  # Result: 3.14159...\n\ngeometry:\n  radius: 5\n  circumference: ${hya.mul:2,${hya.pi:},${geometry.radius}}  # Result: 31.41...\n</code></pre></p> <p>Equivalent Python: <pre><code>import math\n\nvalue = math.pi\n</code></pre></p>"},{"location":"resolvers/#path-utilities","title":"Path Utilities","text":""},{"location":"resolvers/#hyapath","title":"<code>hya.path</code>","text":"<p>Converts a string to a resolved <code>pathlib.Path</code> object with user expansion.</p> <p>Syntax: <code>${hya.path:path_string}</code></p> <p>Example: <pre><code>data_dir: ${hya.path:/data/datasets}\nmodel_path: ${hya.path:~/models/checkpoint.pth}\n</code></pre></p> <p>Equivalent Python: <pre><code>from pathlib import Path\n\nvalue = Path(path).expanduser().resolve()\n</code></pre></p> <p>Note: Returns a <code>pathlib.Path</code> object, which is useful for path operations in Python.</p>"},{"location":"resolvers/#hyato_path","title":"<code>hya.to_path</code>","text":"<p>Converts a string (including file:// URLs) to a <code>pathlib.Path</code> with URL decoding.</p> <p>Syntax: <code>${hya.to_path:path_string}</code></p> <p>Example: <pre><code>local_file: ${hya.to_path:file:///data/file.txt}\nurl_decoded: ${hya.to_path:/path/with%20spaces}\n</code></pre></p> <p>Equivalent Python: <pre><code>from pathlib import Path\nfrom urllib.parse import unquote, urlparse\n\nvalue = Path(unquote(urlparse(path).path)).expanduser().resolve()\n</code></pre></p> <p>Use Case: Handling file URLs and paths with URL encoding.</p>"},{"location":"resolvers/#hyaiter_join","title":"<code>hya.iter_join</code>","text":"<p>Joins elements of an iterable into a string with a separator.</p> <p>Syntax: <code>${hya.iter_join:iterable,separator}</code></p> <p>Example: <pre><code># Simple join\njoined: ${hya.iter_join:[a,b,c],-}  # Result: \"a-b-c\"\n\n# Build paths\npaths:\n  root: data\n  project: myproject\n  version: v1\n  full_path: ${hya.iter_join:[${paths.root},${paths.project},${paths.version}],/}\n  # Result: \"data/myproject/v1\"\n\n# Build experiment names\nexperiment:\n  model: resnet\n  dataset: cifar10\n  name: ${hya.iter_join:[${experiment.model},${experiment.dataset}],_}\n  # Result: \"resnet_cifar10\"\n</code></pre></p> <p>Equivalent Python: <pre><code>value = separator.join(map(str, iterable))\n</code></pre></p> <p>Use Case: Dynamically constructing file paths, experiment names, or configuration strings.</p>"},{"location":"resolvers/#utility-functions","title":"Utility Functions","text":""},{"location":"resolvers/#hyalen","title":"<code>hya.len</code>","text":"<p>Returns the length of an object.</p> <p>Syntax: <code>${hya.len:object}</code></p> <p>Example: <pre><code>list_length: ${hya.len:[1,2,3,4,5]}  # Result: 5\n\nmodel:\n  layer_sizes: [128, 256, 512, 1024]\n  num_layers: ${hya.len:${model.layer_sizes}}  # Result: 4\n</code></pre></p> <p>Equivalent Python: <pre><code>value = len(obj)\n</code></pre></p>"},{"location":"resolvers/#hyasha256","title":"<code>hya.sha256</code>","text":"<p>Computes the SHA-256 hash of an object.</p> <p>Syntax: <code>${hya.sha256:object}</code></p> <p>Example: <pre><code>hash: ${hya.sha256:mystring}\n# Result: \"bd3ff47540b31e62d4ca6b07794e5a886b0f655fc322730f26ecd65cc7dd5c90\"\n\nexperiment:\n  config: \"resnet50_adam_0.001\"\n  version_id: ${hya.sha256:${experiment.config}}\n  # Generates consistent hash for versioning\n</code></pre></p> <p>Equivalent Python: <pre><code>import hashlib\n\nvalue = hashlib.sha256(bytes(str(obj), \"utf-8\")).hexdigest()\n</code></pre></p> <p>Use Case: Creating unique identifiers for experiments, cache keys, or version tracking.</p>"},{"location":"resolvers/#optional-resolvers","title":"Optional Resolvers","text":"<p>These resolvers require additional packages to be installed.</p>"},{"location":"resolvers/#braceexpand","title":"Braceexpand","text":"<p>Package Required: <code>braceexpand&gt;=0.1.7</code></p> <p>Install with: <code>pip install braceexpand</code></p>"},{"location":"resolvers/#hyabraceexpand","title":"<code>hya.braceexpand</code>","text":"<p>Expands brace patterns similar to bash brace expansion.</p> <p>Syntax: <code>${hya.braceexpand:pattern}</code></p> <p>Example: <pre><code># Numeric range\nfiles: ${hya.braceexpand:file_{1..5}.txt}\n# Returns iterator: file_1.txt, file_2.txt, ..., file_5.txt\n\n# Choice expansion\nconfigs: ${hya.braceexpand:config_{train,val,test}.yaml}\n# Returns iterator: config_train.yaml, config_val.yaml, config_test.yaml\n\n# Nested patterns\npaths: ${hya.braceexpand:data/{2020..2022}/{jan,feb,mar}}\n# Returns: data/2020/jan, data/2020/feb, ..., data/2022/mar\n</code></pre></p> <p>Reference: braceexpand documentation</p>"},{"location":"resolvers/#numpy","title":"NumPy","text":"<p>Package Required: <code>numpy&gt;=1.24</code></p> <p>Install with: <code>pip install numpy</code></p>"},{"location":"resolvers/#hyanparray","title":"<code>hya.np.array</code>","text":"<p>Converts data to a NumPy array.</p> <p>Syntax: <code>${hya.np.array:data}</code></p> <p>Example: <pre><code># 1D array\nvector: ${hya.np.array:[1,2,3,4,5]}\n\n# 2D array\nmatrix: ${hya.np.array:[[1,2,3],[4,5,6]]}\n\n# Use in configuration\ndata:\n  shape: [28, 28]\n  default_image: ${hya.np.array:${data.shape}}\n</code></pre></p> <p>Equivalent Python: <pre><code>import numpy as np\n\nvalue = np.array(data)\n</code></pre></p>"},{"location":"resolvers/#pytorch","title":"PyTorch","text":"<p>Package Required: <code>torch&gt;=2.0</code></p> <p>Install with: <code>pip install torch</code></p>"},{"location":"resolvers/#hyatorchtensor","title":"<code>hya.torch.tensor</code>","text":"<p>Converts data to a PyTorch tensor.</p> <p>Syntax: <code>${hya.torch.tensor:data}</code></p> <p>Example: <pre><code># 1D tensor\nweights: ${hya.torch.tensor:[0.1,0.2,0.3,0.4]}\n\n# 2D tensor\nmatrix: ${hya.torch.tensor:[[1,2],[3,4]]}\n\n# Use in model configuration\nmodel:\n  default_bias: ${hya.torch.tensor:[0.0,0.0,0.0]}\n</code></pre></p> <p>Equivalent Python: <pre><code>import torch\n\nvalue = torch.tensor(data)\n</code></pre></p>"},{"location":"resolvers/#hyatorchdtype","title":"<code>hya.torch.dtype</code>","text":"<p>Creates a PyTorch dtype from its string representation.</p> <p>Syntax: <code>${hya.torch.dtype:dtype_name}</code></p> <p>Example: <pre><code># Common dtypes\nfloat_type: ${hya.torch.dtype:float32}\nint_type: ${hya.torch.dtype:int64}\nbool_type: ${hya.torch.dtype:bool}\n\n# Use in model configuration\nmodel:\n  compute_dtype: ${hya.torch.dtype:float16}\n  parameter_dtype: ${hya.torch.dtype:float32}\n\ntraining:\n  use_mixed_precision: true\n  amp_dtype: ${hya.torch.dtype:float16}\n</code></pre></p> <p>Available dtypes: Common dtype string names include <code>float</code>, <code>float16</code>, <code>float32</code>, <code>float64</code>, <code>bfloat16</code>, <code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>bool</code>, <code>complex64</code>, <code>complex128</code>. The exact available dtypes depend on your PyTorch installation. For a complete list, see the PyTorch dtype documentation.</p> <p>Equivalent Python: <pre><code>import torch\n\nvalue = torch.float32  # for dtype_name=\"float32\"\n</code></pre></p>"},{"location":"resolvers/#resolver-categories-summary","title":"Resolver Categories Summary","text":"Category Resolvers Arithmetic <code>add</code>, <code>sub</code>, <code>mul</code>, <code>truediv</code>, <code>floordiv</code>, <code>ceildiv</code>, <code>neg</code> Math Functions <code>pow</code>, <code>sqrt</code>, <code>exp</code>, <code>log</code>, <code>log10</code>, <code>sinh</code>, <code>asinh</code> Comparison <code>max</code>, <code>min</code> Constants <code>pi</code> Paths <code>path</code>, <code>to_path</code>, <code>iter_join</code> Utilities <code>len</code>, <code>sha256</code> Optional <code>braceexpand</code>, <code>np.array</code>, <code>torch.tensor</code>, <code>torch.dtype</code>"},{"location":"resolvers/#quick-reference-examples","title":"Quick Reference Examples","text":""},{"location":"resolvers/#configuration-calculations","title":"Configuration Calculations","text":"<pre><code>training:\n  total_samples: 60000\n  batch_size: 64\n  num_batches: ${hya.ceildiv:${training.total_samples},${training.batch_size}}\n  learning_rate: ${hya.pow:10,-3}\n</code></pre>"},{"location":"resolvers/#path-construction","title":"Path Construction","text":"<pre><code>paths:\n  base: /data\n  project: myproject\n  full_path: ${hya.iter_join:[${paths.base},${paths.project},models],/}\n</code></pre>"},{"location":"resolvers/#data-type-configuration","title":"Data Type Configuration","text":"<pre><code>model:\n  dtype: ${hya.torch.dtype:float32}\n  input_tensor: ${hya.torch.tensor:[1,2,3]}\n</code></pre>"},{"location":"resolvers/#experiment-versioning","title":"Experiment Versioning","text":"<pre><code>experiment:\n  name: resnet50_cifar10\n  hash: ${hya.sha256:${experiment.name}}\n</code></pre>"},{"location":"user_guide/","title":"User Guide","text":"<p>This guide provides comprehensive information on using <code>hya</code> in your projects.</p>"},{"location":"user_guide/#basic-usage","title":"Basic Usage","text":""},{"location":"user_guide/#importing-and-automatic-registration","title":"Importing and Automatic Registration","text":"<p>When you import <code>hya</code>, all default resolvers are automatically registered with OmegaConf:</p> <pre><code>import hya\nfrom omegaconf import OmegaConf\n\n# Resolvers are now available\nconf = OmegaConf.create({\"result\": \"${hya.add:2,3}\"})\nprint(conf.result)  # Output: 5\n</code></pre>"},{"location":"user_guide/#using-resolvers-in-yaml-configurations","title":"Using Resolvers in YAML Configurations","text":"<p>You can use resolvers directly in YAML configuration files:</p> <pre><code># config.yaml\nmodel:\n  layers: 4\n  hidden_size: 256\n  # NOTE: This is a simple demonstration of the mul resolver\n  # Real neural network parameter counts are much more complex\n  approx_params: ${hya.mul:${model.layers},${model.hidden_size}}\n\ntraining:\n  total_samples: 10000\n  batch_size: 32\n  num_batches: ${hya.ceildiv:${training.total_samples},${training.batch_size}}\n  learning_rate: ${hya.pow:10,-3}  # 10^-3 = 0.001\n</code></pre> <p>Load and use the configuration:</p> <pre><code>import hya\nfrom omegaconf import OmegaConf\n\nconf = OmegaConf.load(\"config.yaml\")\nprint(conf.model.approx_params)  # Output: 1024\nprint(conf.training.num_batches)  # Output: 313\nprint(conf.training.learning_rate)  # Output: 0.001\n</code></pre>"},{"location":"user_guide/#integration-with-hydra","title":"Integration with Hydra","text":"<p><code>hya</code> is designed to work seamlessly with Hydra.</p>"},{"location":"user_guide/#basic-hydra-example","title":"Basic Hydra Example","text":"<p>config.yaml: <pre><code>dataset:\n  name: mnist\n  train_samples: 60000\n  val_samples: 10000\n  total_samples: ${hya.add:${dataset.train_samples},${dataset.val_samples}}\n\nmodel:\n  type: cnn\n  channels: [32, 64, 128]\n  num_layers: ${hya.len:${model.channels}}\n\ntraining:\n  batch_size: 64\n  epochs: 10\n  steps_per_epoch: ${hya.ceildiv:${dataset.train_samples},${training.batch_size}}\n\npaths:\n  root: /data\n  train: ${hya.iter_join:[${paths.root},${dataset.name},train],/}\n  val: ${hya.iter_join:[${paths.root},${dataset.name},val],/}\n\nexperiment:\n  name: ${dataset.name}_${model.type}\n  version: ${hya.sha256:${experiment.name}}\n</code></pre></p> <p>train.py: <pre><code>import hya\nimport hydra\nfrom omegaconf import DictConfig\n\n\n@hydra.main(version_base=None, config_path=\".\", config_name=\"config\")\ndef train(cfg: DictConfig):\n    print(f\"Dataset: {cfg.dataset.name}\")\n    print(f\"Total samples: {cfg.dataset.total_samples}\")\n    print(f\"Model layers: {cfg.model.num_layers}\")\n    print(f\"Steps per epoch: {cfg.training.steps_per_epoch}\")\n    print(f\"Train path: {cfg.paths.train}\")\n    print(f\"Experiment version: {cfg.experiment.version}\")\n\n\nif __name__ == \"__main__\":\n    train()\n</code></pre></p>"},{"location":"user_guide/#multi-config-with-hydra","title":"Multi-Config with Hydra","text":"<p>You can use <code>hya</code> resolvers across multiple configuration files:</p> <p>config.yaml: <pre><code>defaults:\n  - model: resnet\n  - optimizer: adam\n\nexperiment:\n  name: ${model.name}_${optimizer.name}\n  seed: 42\n  version: ${hya.sha256:${experiment.name}_${experiment.seed}}\n</code></pre></p> <p>model/resnet.yaml: <pre><code>name: resnet\ndepth: 50\nwidth_multiplier: 1.0\neffective_depth: ${hya.mul:${model.depth},${model.width_multiplier}}\n</code></pre></p> <p>optimizer/adam.yaml: <pre><code>name: adam\nlr: ${hya.pow:10,-4}  # 0.0001\nbetas: [0.9, 0.999]\n</code></pre></p>"},{"location":"user_guide/#custom-resolvers","title":"Custom Resolvers","text":""},{"location":"user_guide/#creating-and-registering-custom-resolvers","title":"Creating and Registering Custom Resolvers","text":"<p>You can extend <code>hya</code> with your own custom resolvers:</p> <pre><code>from hya import get_default_registry\n\n# Get the default registry\nregistry = get_default_registry()\n\n\n# Register a simple custom resolver\n@registry.register(\"double\")\ndef double_resolver(x):\n    \"\"\"Double the input value.\"\"\"\n    return x * 2\n\n\n# Register a more complex resolver\n@registry.register(\"clip\")\ndef clip_resolver(value, min_val, max_val):\n    \"\"\"Clip a value between min and max.\"\"\"\n    return max(min_val, min(value, max_val))\n\n\n# Register custom resolvers with OmegaConf\n# Note: Default hya resolvers are already registered on import\n# This only registers your custom resolvers added to the default registry\nregistry.register_resolvers()\n</code></pre> <p>Now use them in your configuration:</p> <pre><code>hyperparameters:\n  base_lr: 0.001\n  scaled_lr: ${double:${hyperparameters.base_lr}}\n\n  dropout: 0.7\n  clipped_dropout: ${clip:${hyperparameters.dropout},0.0,0.5}\n</code></pre>"},{"location":"user_guide/#overriding-existing-resolvers","title":"Overriding Existing Resolvers","text":"<p>You can override existing resolvers using the <code>exist_ok</code> parameter:</p> <pre><code>from hya import get_default_registry\n\nregistry = get_default_registry()\n\n\n@registry.register(\"hya.add\", exist_ok=True)\ndef custom_add(*args):\n    \"\"\"Custom add that also prints the result.\"\"\"\n    result = sum(args)\n    print(f\"Adding {args} = {result}\")\n    return result\n\n\nregistry.register_resolvers()\n</code></pre>"},{"location":"user_guide/#creating-isolated-registries","title":"Creating Isolated Registries","text":"<p>For advanced use cases, you can create independent registries:</p> <pre><code>from hya.registry import ResolverRegistry\n\n# Create a new, isolated registry\ncustom_registry = ResolverRegistry()\n\n\n@custom_registry.register(\"custom.multiply\")\ndef multiply(x, y):\n    return x * y\n\n\n# Register only these custom resolvers\ncustom_registry.register_resolvers()\n</code></pre>"},{"location":"user_guide/#common-use-cases","title":"Common Use Cases","text":""},{"location":"user_guide/#path-construction","title":"Path Construction","text":"<p>Build file paths dynamically:</p> <pre><code>paths:\n  root: /data\n  project: myproject\n  version: v1\n\n  # Build paths using iter_join\n  data_dir: ${hya.iter_join:[${paths.root},${paths.project},${paths.version}],/}\n  train_file: ${hya.iter_join:[${paths.data_dir},train.csv],/}\n\n  # Use path resolver for proper Path objects\n  model_checkpoint: ${hya.path:${paths.data_dir}/models/checkpoint.pth}\n</code></pre>"},{"location":"user_guide/#mathematical-computations","title":"Mathematical Computations","text":"<p>Perform calculations in your configuration:</p> <pre><code>model:\n  embedding_dim: 512\n  num_heads: 8\n  head_dim: ${hya.floordiv:${model.embedding_dim},${model.num_heads}}  # 64\n\ntraining:\n  total_steps: 100000\n  warmup_ratio: 0.1\n  warmup_steps: ${hya.mul:${training.total_steps},${training.warmup_ratio}}  # 10000\n\n  # Calculate batch size for distributed training\n  per_device_batch_size: 16\n  num_devices: 4\n  global_batch_size: ${hya.mul:${training.per_device_batch_size},${training.num_devices}}\n</code></pre>"},{"location":"user_guide/#data-type-specifications-pytorch","title":"Data Type Specifications (PyTorch)","text":"<p>Specify tensor data types in configuration:</p> <pre><code>model:\n  dtype: ${hya.torch.dtype:float32}\n  use_half_precision: false\n  compute_dtype: ${hya.torch.dtype:float16}\n\ndata:\n  input_shape: [3, 224, 224]\n  dummy_input: ${hya.torch.tensor:${data.input_shape}}\n</code></pre>"},{"location":"user_guide/#versioning-and-hashing","title":"Versioning and Hashing","text":"<p>Generate consistent identifiers:</p> <pre><code>experiment:\n  model_name: resnet50\n  dataset: imagenet\n  augmentation: heavy\n\n  # Create a unique experiment ID\n  full_name: ${experiment.model_name}_${experiment.dataset}_${experiment.augmentation}\n  experiment_id: ${hya.sha256:${experiment.full_name}}\n\n  # Use for reproducible paths\n  output_dir: ${hya.iter_join:[outputs,${experiment.experiment_id}],/}\n</code></pre>"},{"location":"user_guide/#list-operations","title":"List Operations","text":"<p>Work with lists and sequences:</p> <pre><code>datasets:\n  train: [mnist, cifar10, imagenet]\n  num_datasets: ${hya.len:${datasets.train}}\n\n  # Join dataset names\n  combined_name: ${hya.iter_join:${datasets.train},_}  # mnist_cifar10_imagenet\n</code></pre>"},{"location":"user_guide/#brace-expansion-requires-braceexpand","title":"Brace Expansion (requires braceexpand)","text":"<p>Generate multiple values from patterns:</p> <pre><code>files:\n  # Expands to iterator: file_1.txt, file_2.txt, ..., file_5.txt\n  pattern: ${hya.braceexpand:file_{1..5}.txt}\n\n  # Expands to: train_a.json, train_b.json, train_c.json\n  train_configs: ${hya.braceexpand:train_{a,b,c}.json}\n</code></pre>"},{"location":"user_guide/#registry-api","title":"Registry API","text":""},{"location":"user_guide/#checking-for-resolvers","title":"Checking for Resolvers","text":"<p>Check if a resolver is registered:</p> <pre><code>from hya import get_default_registry\n\nregistry = get_default_registry()\n\n# Check if a resolver exists\nif registry.has_resolver(\"hya.add\"):\n    print(\"add resolver is available\")\n\n# List all registered resolvers\nfor key in registry.state.keys():\n    print(f\"Registered: {key}\")\n</code></pre>"},{"location":"user_guide/#accessing-registry-state","title":"Accessing Registry State","text":"<pre><code>from hya import get_default_registry\n\nregistry = get_default_registry()\n\n# Get all registered resolvers\nresolvers_dict = registry.state\n\n# Count resolvers\nprint(f\"Total resolvers: {len(resolvers_dict)}\")\n\n# Check specific resolvers\ncore_resolvers = [k for k in resolvers_dict.keys() if k.startswith(\"hya.\")]\nprint(f\"Core hya resolvers: {len(core_resolvers)}\")\n</code></pre>"},{"location":"user_guide/#best-practices","title":"Best Practices","text":""},{"location":"user_guide/#configuration-organization","title":"Configuration Organization","text":"<p>Organize your configurations for maintainability:</p> <pre><code># Good: Use resolvers to avoid duplication\nmodel:\n  hidden_size: 768\n  num_layers: 12\n  total_hidden: ${hya.mul:${model.hidden_size},${model.num_layers}}\n\n# Avoid: Hardcoding computed values\n# total_hidden: 9216  # If you change hidden_size, this becomes incorrect\n</code></pre>"},{"location":"user_guide/#error-handling","title":"Error Handling","text":"<p>When using optional resolvers, provide helpful error messages:</p> <pre><code>import hya\nfrom omegaconf import OmegaConf, errors\n\ntry:\n    conf = OmegaConf.create({\"tensor\": \"${hya.torch.tensor:[1,2,3]}\"})\n    print(conf.tensor)\nexcept errors.InterpolationResolutionError as e:\n    print(f\"Error: PyTorch is required. Install with: pip install torch\")\n</code></pre>"},{"location":"user_guide/#type-safety","title":"Type Safety","text":"<p>Use appropriate resolvers for type safety:</p> <pre><code># Good: Use correct division operators\nsamples: 1000\nbatch_size: 32\nnum_batches: ${hya.ceildiv:${samples},${batch_size}}  # Integer result: 32\n\n# Avoid: Using wrong division type\n# num_batches: ${hya.truediv:${samples},${batch_size}}  # Float result: 31.25\n</code></pre>"},{"location":"user_guide/#performance-considerations","title":"Performance Considerations","text":"<p>Resolvers are evaluated lazily when accessed:</p> <pre><code>conf = OmegaConf.create(\n    {\"slow_computation\": \"${hya.pow:2,1000}\", \"fast_value\": 42}  # Not computed yet\n)\n\n# Only computed when accessed\nresult = conf.slow_computation  # Computed here\n</code></pre> <p>Cache expensive computations:</p> <pre><code># Good: Compute once, reuse\nmodel:\n  vocab_size: 50000\n  embedding_dim: 512\n  total_embeddings: ${hya.mul:${model.vocab_size},${model.embedding_dim}}\n\nlayer1:\n  input_size: ${model.total_embeddings}  # Reuses cached computation\n\nlayer2:\n  input_size: ${model.total_embeddings}  # Reuses cached computation\n</code></pre>"},{"location":"user_guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user_guide/#resolver-not-found","title":"Resolver Not Found","text":"<p>Error: <code>omegaconf.errors.UnsupportedInterpolationType: Unsupported interpolation type hya.xxx</code></p> <p>Solution: Make sure you have imported <code>hya</code>:</p> <pre><code>import hya  # This line is required!\nfrom omegaconf import OmegaConf\n</code></pre>"},{"location":"user_guide/#optional-dependency-missing","title":"Optional Dependency Missing","text":"<p>Error: <code>ImportError: braceexpand is required to use hya.braceexpand resolver</code></p> <p>Solution: Install the required package:</p> <pre><code>pip install braceexpand  # or numpy, or torch\n</code></pre>"},{"location":"user_guide/#resolver-already-registered","title":"Resolver Already Registered","text":"<p>Error: <code>RuntimeError: A resolver is already registered for 'my_key'</code></p> <p>Solution: Use <code>exist_ok=True</code> to override:</p> <pre><code>@registry.register(\"my_key\", exist_ok=True)\ndef my_resolver(x):\n    return x\n</code></pre>"},{"location":"user_guide/#type-errors-in-resolvers","title":"Type Errors in Resolvers","text":"<p>Error: <code>TypeError: unsupported operand type(s) for +: 'int' and 'str'</code></p> <p>Solution: Ensure your configuration passes correct types:</p> <pre><code># Wrong: Mixing types\nresult: ${hya.add:5,abc}\n\n# Correct: Same types\nresult: ${hya.add:5,10}\n</code></pre>"},{"location":"user_guide/#circular-references","title":"Circular References","text":"<p>Error: <code>omegaconf.errors.InterpolationResolutionError: Circular reference detected</code></p> <p>Solution: Avoid self-referential configurations:</p> <pre><code># Wrong: Circular reference\nx: ${hya.add:${y},1}\ny: ${hya.add:${x},1}\n\n# Correct: No circular dependency\nx: 5\ny: ${hya.add:${x},1}\n</code></pre>"},{"location":"user_guide/#advanced-topics","title":"Advanced Topics","text":""},{"location":"user_guide/#working-with-complex-data-types","title":"Working with Complex Data Types","text":"<p>Create NumPy arrays and PyTorch tensors:</p> <pre><code>import hya\nfrom omegaconf import OmegaConf\n\nconf = OmegaConf.create(\n    {\n        \"numpy_array\": \"${hya.np.array:[[1,2,3],[4,5,6]]}\",\n        \"torch_tensor\": \"${hya.torch.tensor:[1.0,2.0,3.0]}\",\n        \"torch_dtype\": \"${hya.torch.dtype:float32}\",\n    }\n)\n\nprint(type(conf.numpy_array))  # &lt;class 'numpy.ndarray'&gt;\nprint(type(conf.torch_tensor))  # &lt;class 'torch.Tensor'&gt;\nprint(conf.torch_dtype)  # torch.float32\n</code></pre>"},{"location":"user_guide/#combining-multiple-resolvers","title":"Combining Multiple Resolvers","text":"<p>Chain resolvers for complex operations:</p> <pre><code>model:\n  base_size: 64\n  multiplier: 4\n  layers: 3\n\n  # Compute total size: (64 * 4) * 3 = 768\n  intermediate_size: ${hya.mul:${model.base_size},${model.multiplier}}\n  total_size: ${hya.mul:${model.intermediate_size},${model.layers}}\n</code></pre>"},{"location":"user_guide/#using-resolvers-with-omegaconf-features","title":"Using Resolvers with OmegaConf Features","text":"<p>Combine resolvers with OmegaConf's native features:</p> <pre><code>defaults:\n  - base_config\n\n# Use resolvers with variable interpolation\npaths:\n  root: /data\n  project: ${oc.env:PROJECT_NAME,default_project}\n  output: ${hya.iter_join:[${paths.root},${paths.project}],/}\n\n# Use resolvers with optional values\nmodel:\n  size: ${size:512}  # Can be overridden via command line\n  doubled_size: ${hya.mul:${model.size},2}\n</code></pre>"},{"location":"refs/","title":"Main functions","text":""},{"location":"refs/#hya","title":"hya","text":"<p>Contain the main features of the <code>hya</code> package.</p>"},{"location":"refs/#hya.get_default_registry","title":"hya.get_default_registry","text":"<pre><code>get_default_registry() -&gt; ResolverRegistry\n</code></pre> <p>Get or create the default global resolver registry.</p> <p>Returns a singleton registry instance using a simple singleton pattern. The registry is initially empty and can be populated with custom resolvers.</p> <p>This function uses a singleton pattern to ensure the same registry instance is returned on subsequent calls, which is efficient and maintains consistency across an application.</p> <p>Returns:</p> Type Description <code>ResolverRegistry</code> <p>A ResolverRegistry instance</p> Notes <p>The singleton pattern means modifications to the returned registry affect all future calls to this function. If you need an isolated registry, create a new ResolverRegistry instance directly.</p> Example <pre><code>&gt;&gt;&gt; from hya import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; @registry.register(\"my_key\")\n... def my_resolver(value):\n...     pass\n...\n</code></pre>"},{"location":"refs/registry/","title":"Registry","text":""},{"location":"refs/registry/#hya.registry","title":"hya.registry","text":"<p>Implement the resolver registry to easily register resolvers.</p>"},{"location":"refs/registry/#hya.registry.ResolverRegistry","title":"hya.registry.ResolverRegistry","text":"<p>Implement a resolver registry.</p> <p>This class manages a collection of resolver functions that can be registered with keys and later used with OmegaConf.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>dict[str, Callable[..., Any]] | None</code> <p>Optional initial state dictionary containing key-resolver pairs. If provided, a copy is made to prevent external modifications.</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; from hya.registry import ResolverRegistry\n&gt;&gt;&gt; registry = ResolverRegistry()\n&gt;&gt;&gt; @registry.register(\"my_key\")\n... def my_resolver(value):\n...     pass\n...\n</code></pre>"},{"location":"refs/registry/#hya.registry.ResolverRegistry.state","title":"hya.registry.ResolverRegistry.state  <code>property</code>","text":"<pre><code>state: dict[str, Callable[..., Any]]\n</code></pre> <p>The state of the registry.</p>"},{"location":"refs/registry/#hya.registry.ResolverRegistry.has_resolver","title":"hya.registry.ResolverRegistry.has_resolver","text":"<pre><code>has_resolver(key: str) -&gt; bool\n</code></pre> <p>Check if a resolver is explicitly registered for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a resolver is registered for this key,</p> <code>bool</code> <p>False otherwise</p> Example <pre><code>&gt;&gt;&gt; from hya.registry import ResolverRegistry\n&gt;&gt;&gt; registry = ResolverRegistry()\n&gt;&gt;&gt; @registry.register(\"my_key\")\n... def my_resolver(value):\n...     pass\n...\n&gt;&gt;&gt; registry.has_resolver(\"my_key\")\nTrue\n&gt;&gt;&gt; registry.has_resolver(\"missing\")\nFalse\n</code></pre>"},{"location":"refs/registry/#hya.registry.ResolverRegistry.register","title":"hya.registry.ResolverRegistry.register","text":"<pre><code>register(\n    key: str, exist_ok: bool = False\n) -&gt; Callable[[F], F]\n</code></pre> <p>Register a resolver to registry with the specified key.</p> <p>This method returns a decorator that can be used to register resolver functions.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key used to register the resolver. Must be unique unless exist_ok is True.</p> required <code>exist_ok</code> <code>bool</code> <p>If False, a RuntimeError is raised if you try to register a new resolver with an existing key. If True, the existing resolver will be overridden.</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[F], F]</code> <p>A decorator function that registers the resolver and returns it unchanged.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the resolver is not callable.</p> <code>RuntimeError</code> <p>If the key already exists and exist_ok is False.</p> Example <pre><code>&gt;&gt;&gt; from hya.registry import ResolverRegistry\n&gt;&gt;&gt; registry = ResolverRegistry()\n&gt;&gt;&gt; @registry.register(\"my_key\")\n... def my_resolver(value):\n...     return value * 2\n...\n&gt;&gt;&gt; my_resolver(5)\n10\n</code></pre>"},{"location":"refs/registry/#hya.registry.ResolverRegistry.register_resolvers","title":"hya.registry.ResolverRegistry.register_resolvers","text":"<pre><code>register_resolvers() -&gt; None\n</code></pre> <p>Register the resolvers to OmegaConf.</p> <p>This method iterates through all registered resolvers and registers them with OmegaConf if they haven't been registered already.</p> Example <pre><code>&gt;&gt;&gt; from hya.registry import ResolverRegistry\n&gt;&gt;&gt; registry = ResolverRegistry()\n&gt;&gt;&gt; @registry.register(\"multiply\")\n... def multiply_resolver(x, y):\n...     return x * y\n...\n&gt;&gt;&gt; registry.register_resolvers()\n</code></pre>"},{"location":"refs/resolvers/","title":"Resolvers","text":""},{"location":"refs/resolvers/#native-resolvers","title":"Native resolvers","text":""},{"location":"refs/resolvers/#hya.resolvers","title":"hya.resolvers","text":"<p>Implement some resolvers using features from standard libraries.</p>"},{"location":"refs/resolvers/#hya.resolvers.add_resolver","title":"hya.resolvers.add_resolver","text":"<pre><code>add_resolver(*args: Any) -&gt; Any\n</code></pre> <p>Return the addition of several objects.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>The values to add.</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p><code>arg1 + arg2 + arg3 + ... + argN</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.add:1,2}\"})\n&gt;&gt;&gt; conf.key\n3\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.add:1,2,3,4}\"})\n&gt;&gt;&gt; conf.key\n10\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.asinh_resolver","title":"hya.resolvers.asinh_resolver","text":"<pre><code>asinh_resolver(number: float) -&gt; float\n</code></pre> <p>Return the inverse hyperbolic sine.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to transform.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The inverse hyperbolic sine of the input number.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.asinh:1}\"})\n&gt;&gt;&gt; conf.key\n0.881373...\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.ceildiv_resolver","title":"hya.resolvers.ceildiv_resolver","text":"<pre><code>ceildiv_resolver(dividend: float, divisor: float) -&gt; float\n</code></pre> <p>Compute the ceiling division of two numbers.</p> <p>Ceiling division rounds the result up to the nearest integer, which is useful for calculating the minimum number of chunks needed to accommodate a given total.</p> <p>Parameters:</p> Name Type Description Default <code>dividend</code> <code>float</code> <p>The dividend (numerator).</p> required <code>divisor</code> <code>float</code> <p>The divisor (denominator).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The ceiling of dividend / divisor. Equivalent to</p> <code>float</code> <p>math.ceil(dividend / divisor).</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.ceildiv:11,4}\"})\n&gt;&gt;&gt; conf.key\n3\n&gt;&gt;&gt; # Useful for calculating number of batches\n&gt;&gt;&gt; conf = OmegaConf.create({\"batches\": \"${hya.ceildiv:100,32}\"})\n&gt;&gt;&gt; conf.batches\n4\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.exp_resolver","title":"hya.resolvers.exp_resolver","text":"<pre><code>exp_resolver(number: float) -&gt; float\n</code></pre> <p>Return the exponential value of the input.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to transform.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The exponential value of the input.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.exp:0}\"})\n&gt;&gt;&gt; conf.key\n1.0\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.floordiv_resolver","title":"hya.resolvers.floordiv_resolver","text":"<pre><code>floordiv_resolver(dividend: float, divisor: float) -&gt; float\n</code></pre> <p>Compute the floor division of two numbers.</p> <p>Floor division rounds the result down to the nearest integer, equivalent to the // operator in Python.</p> <p>Parameters:</p> Name Type Description Default <code>dividend</code> <code>float</code> <p>The dividend (numerator).</p> required <code>divisor</code> <code>float</code> <p>The divisor (denominator).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The floor of dividend / divisor, i.e., <code>dividend // divisor</code>.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.floordiv:11,4}\"})\n&gt;&gt;&gt; conf.key\n2\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.floordiv:10,3}\"})\n&gt;&gt;&gt; conf.key\n3\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.iter_join_resolver","title":"hya.resolvers.iter_join_resolver","text":"<pre><code>iter_join_resolver(\n    iterable: Iterable[Any], separator: str\n) -&gt; str\n</code></pre> <p>Convert all items in an iterable to strings and join them.</p> <p>This resolver takes an iterable (e.g., list, tuple) and concatenates all elements into a single string, separated by the specified separator. Each element is converted to a string using str().</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[Any]</code> <p>Any iterable object where all the returned values are strings or can be converted to string. Common examples include lists, tuples, or OmegaConf ListConfig objects.</p> required <code>separator</code> <code>str</code> <p>The separator string to use between the items. Can be any string including empty string, space, comma, etc.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A single string with all iterable elements joined by the separator.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.iter_join:[abc,2,def],-}\"})\n&gt;&gt;&gt; conf.key\nabc-2-def\n&gt;&gt;&gt; conf = OmegaConf.create({\"path\": \"${hya.iter_join:[data,models,v1],/}\"})\n&gt;&gt;&gt; conf.path\ndata/models/v1\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.len_resolver","title":"hya.resolvers.len_resolver","text":"<pre><code>len_resolver(obj: Any) -&gt; int\n</code></pre> <p>Return the length of an object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The length of the object.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.len:[1,2,3]}\"})\n&gt;&gt;&gt; conf.key\n3\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.log10_resolver","title":"hya.resolvers.log10_resolver","text":"<pre><code>log10_resolver(number: float) -&gt; float\n</code></pre> <p>Compute base 10 logarithm of the input value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to transform.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The base 10 logarithm of the input value.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.log10:1}\"})\n&gt;&gt;&gt; conf.key\n0.0\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.log_resolver","title":"hya.resolvers.log_resolver","text":"<pre><code>log_resolver(number: float, base: float = e) -&gt; float\n</code></pre> <p>Compute logarithm of the input value to the given base.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to transform.</p> required <code>base</code> <code>float</code> <p>The base.</p> <code>e</code> <p>Returns:</p> Type Description <code>float</code> <p>The logarithm of the input value to the given base.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.log:1}\"})\n&gt;&gt;&gt; conf.key\n0.0\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.max_resolver","title":"hya.resolvers.max_resolver","text":"<pre><code>max_resolver(*args: Any) -&gt; Any\n</code></pre> <p>Return the maximum between multiple values.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>The values.</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p><code>max(arg1, arg2, arg3, ..., argN)</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.max:1,2,3}\"})\n&gt;&gt;&gt; conf.key\n3\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.min_resolver","title":"hya.resolvers.min_resolver","text":"<pre><code>min_resolver(*args: Any) -&gt; Any\n</code></pre> <p>Return the minimum between multiple values.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>The values.</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p><code>min(arg1, arg2, arg3, ..., argN)</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.min:1,2,3}\"})\n&gt;&gt;&gt; conf.key\n1\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.mul_resolver","title":"hya.resolvers.mul_resolver","text":"<pre><code>mul_resolver(*args: Any) -&gt; Any\n</code></pre> <p>Return the multiplication of several objects.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>The values to multiply.</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p><code>arg1 * arg2 * arg3 * ... * argN</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.mul:1,2}\"})\n&gt;&gt;&gt; conf.key\n2\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.mul:1,2,3}\"})\n&gt;&gt;&gt; conf.key\n6\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.neg_resolver","title":"hya.resolvers.neg_resolver","text":"<pre><code>neg_resolver(number: float) -&gt; float\n</code></pre> <p>Return the negation (<code>-number</code>).</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to transform.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The negated input number.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.neg:1}\"})\n&gt;&gt;&gt; conf.key\n-1\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.path_resolver","title":"hya.resolvers.path_resolver","text":"<pre><code>path_resolver(path: str) -&gt; Path\n</code></pre> <p>Return a resolved path object from a string path.</p> <p>This resolver converts a string path to a pathlib.Path object, expanding user home directory references (~) and resolving to an absolute path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The target path as a string. Supports tilde (~) for home directory expansion.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>A fully resolved pathlib.Path object with expanded user</p> <code>Path</code> <p>directory and converted to absolute path.</p> Note <p>The tilde (~) expansion works when the path is passed as a regular string, but may not work correctly when used within OmegaConf interpolation syntax due to grammar restrictions. For paths with tilde, consider using direct Python code or configuration string values.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.path:/my/path}\"})\n&gt;&gt;&gt; conf.key\nPosixPath('/my/path')\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.pi_resolver","title":"hya.resolvers.pi_resolver","text":"<pre><code>pi_resolver() -&gt; float\n</code></pre> <p>Return the value PI.</p> <p>Returns:</p> Type Description <code>float</code> <p>The value of PI.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.pi:}\"})\n&gt;&gt;&gt; conf.key\n3.14159...\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.pow_resolver","title":"hya.resolvers.pow_resolver","text":"<pre><code>pow_resolver(value: float, exponent: float) -&gt; float\n</code></pre> <p>Return a value to a given power.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value or base.</p> required <code>exponent</code> <code>float</code> <p>The exponent.</p> required <p>Returns:</p> Type Description <code>float</code> <p><code>x ** y</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.pow:2,3}\"})\n&gt;&gt;&gt; conf.key\n8\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.sha256_resolver","title":"hya.resolvers.sha256_resolver","text":"<pre><code>sha256_resolver(obj: Any) -&gt; str\n</code></pre> <p>Compute the SHA-256 hash of an input object.</p> <p>This resolver converts the object to a string representation and computes its SHA-256 hash. Useful for generating consistent identifiers or cache keys from configuration values.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to compute the SHA-256 hash. The object will be converted to a string using str() before hashing.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The SHA-256 hash as a hexadecimal string (64 characters).</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.sha256:mystring}\"})\n&gt;&gt;&gt; conf.key\nbd3ff47540b31e62d4ca6b07794e5a886b0f655fc322730f26ecd65cc7dd5c90\n&gt;&gt;&gt; # Useful for generating consistent IDs\n&gt;&gt;&gt; conf = OmegaConf.create({\"id\": \"${hya.sha256:experiment_v1}\"})\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.sinh_resolver","title":"hya.resolvers.sinh_resolver","text":"<pre><code>sinh_resolver(number: float) -&gt; float\n</code></pre> <p>Return the hyperbolic sine.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to transform.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The hyperbolic sine of the input number.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.sinh:1}\"})\n&gt;&gt;&gt; conf.key\n1.175201...\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.sqrt_resolver","title":"hya.resolvers.sqrt_resolver","text":"<pre><code>sqrt_resolver(number: float) -&gt; float\n</code></pre> <p>Return the square root of a number.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to compute the square root.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The square root of the input number.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.sqrt:4}\"})\n&gt;&gt;&gt; conf.key\n2.0\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.sub_resolver","title":"hya.resolvers.sub_resolver","text":"<pre><code>sub_resolver(object1: Any, object2: Any) -&gt; Any\n</code></pre> <p>Return the subtraction of two objects.</p> <p>Parameters:</p> Name Type Description Default <code>object1</code> <code>Any</code> <p>The first object.</p> required <code>object2</code> <code>Any</code> <p>The second object.</p> required <p>Returns:</p> Type Description <code>Any</code> <p><code>object1 - object2</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.sub:3,1}\"})\n&gt;&gt;&gt; conf.key\n2\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.to_path_resolver","title":"hya.resolvers.to_path_resolver","text":"<pre><code>to_path_resolver(path: str) -&gt; Path\n</code></pre> <p>Convert a path string (including URLs) into a <code>pathlib.Path</code>.</p> <p>This resolver handles both regular file paths and file:// URLs, converting them to pathlib.Path objects. It also expands user home directory references and resolves to absolute paths.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to convert. Can be a regular file path or a file:// URL. URL encoding (e.g., %20 for spaces) is automatically decoded. Supports tilde (~) for home directory expansion.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>A fully resolved pathlib.Path object with URL decoding,</p> <code>Path</code> <p>expanded user directory, and converted to absolute path.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.to_path:/my/path}\"})\n&gt;&gt;&gt; conf.key\nPosixPath('/my/path')\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.to_path:file:///my/path}\"})\n&gt;&gt;&gt; conf.key\nPosixPath('/my/path')\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.truediv_resolver","title":"hya.resolvers.truediv_resolver","text":"<pre><code>truediv_resolver(dividend: float, divisor: float) -&gt; float\n</code></pre> <p>Return the true division of two numbers.</p> <p>Parameters:</p> Name Type Description Default <code>dividend</code> <code>float</code> <p>The dividend.</p> required <code>divisor</code> <code>float</code> <p>The divisor.</p> required <p>Returns:</p> Type Description <code>float</code> <p><code>dividend / divisor</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.truediv:1,2}\"})\n&gt;&gt;&gt; conf.key\n0.5\n</code></pre>"},{"location":"refs/resolvers/#optional-resolvers","title":"Optional resolvers","text":""},{"location":"refs/resolvers/#hya.braceexpand","title":"hya.braceexpand","text":"<p>Implement a braceexpand resolver for brace expansion patterns.</p> <p>This module provides OmegaConf resolvers that use the braceexpand library to expand string patterns with brace notation (similar to bash brace expansion). The resolver is registered only if the <code>braceexpand</code> package is available.</p>"},{"location":"refs/resolvers/#hya.braceexpand.braceexpand_resolver","title":"hya.braceexpand.braceexpand_resolver","text":"<pre><code>braceexpand_resolver(pattern: str) -&gt; Iterator[str]\n</code></pre> <p>Return an iterator from a brace expansion of pattern.</p> <p>This resolver expands a string with brace patterns similar to bash brace expansion, generating multiple strings from a single pattern. Useful for generating lists of similar configuration values.</p> <p>Please check https://github.com/trendels/braceexpand for more information about the syntax.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Specifies the pattern of the brace expansion. Supports numeric ranges (e.g., \"file{1..3}.txt\"), character sequences (e.g., \"{a,b,c}\"), and nested patterns.</p> required <p>Returns:</p> Type Description <code>Iterator[str]</code> <p>An iterator yielding strings resulting from brace expansion</p> <code>Iterator[str]</code> <p>of the pattern.</p> Note <p>When using brace expansion patterns in OmegaConf, you may need to escape or quote the pattern string to avoid conflicts with OmegaConf's own syntax for curly braces.</p>"},{"location":"refs/resolvers/#hya.numpy","title":"hya.numpy","text":"<p>Implement NumPy resolvers for array creation and manipulation.</p> <p>This module provides OmegaConf resolvers that use NumPy for array operations. The resolvers are registered only if the <code>numpy</code> package is available, allowing users to create NumPy arrays directly from configuration files.         registry.register_resolvers()</p> <pre><code>    # Then in your OmegaConf config:\n    # data: ${hya.np.array:[1, 2, 3]}\n</code></pre>"},{"location":"refs/resolvers/#hya.numpy.to_array_resolver","title":"hya.numpy.to_array_resolver","text":"<pre><code>to_array_resolver(data: ArrayLike) -&gt; ndarray\n</code></pre> <p>Implement a resolver to transform the input to a <code>numpy.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ArrayLike</code> <p>Specifies the data to transform in <code>numpy.ndarray</code>. This value should be compatible with <code>numpy.array</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The input in a <code>numpy.ndarray</code> object.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.np.array:[1, 2, 3]}\"})\n&gt;&gt;&gt; conf.key\narray([1, 2, 3])\n</code></pre>"},{"location":"refs/resolvers/#hya.torch","title":"hya.torch","text":"<p>Implement PyTorch resolvers for tensor creation and dtype handling.</p> <p>This module provides OmegaConf resolvers that use PyTorch for tensor operations and data type specifications. The resolvers are registered only if the <code>torch</code> package is available, enabling users to create PyTorch tensors and specify dtypes directly from configuration files.</p>"},{"location":"refs/resolvers/#hya.torch.get_dtypes","title":"hya.torch.get_dtypes","text":"<pre><code>get_dtypes() -&gt; set[dtype]\n</code></pre> <p>Get all available PyTorch data types.</p> <p>This function introspects the torch module to find all available dtype objects. It's useful for validation and error messages when working with torch dtype resolvers.</p> <p>Returns:</p> Type Description <code>set[dtype]</code> <p>A set containing all PyTorch dtype objects available in the</p> <code>set[dtype]</code> <p>current torch installation (e.g., torch.float32, torch.int64,</p> <code>set[dtype]</code> <p>torch.bool, etc.).</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from hya.torch import get_dtypes\n&gt;&gt;&gt; dtypes = get_dtypes()\n&gt;&gt;&gt; torch.float32 in dtypes\nTrue\n</code></pre>"},{"location":"refs/resolvers/#hya.torch.to_tensor_resolver","title":"hya.torch.to_tensor_resolver","text":"<pre><code>to_tensor_resolver(data: Any) -&gt; Tensor\n</code></pre> <p>Implement a resolver to transform the input to a <code>torch.Tensor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Specifies the data to transform in <code>torch.Tensor</code>. This value should be compatible with <code>torch.tensor</code></p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The input in a <code>torch.Tensor</code> object.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.torch.tensor:[1,2,3,4,5]}\"})\n&gt;&gt;&gt; conf.key\ntensor([1, 2, 3, 4, 5])\n</code></pre>"},{"location":"refs/resolvers/#hya.torch.torch_dtype_resolver","title":"hya.torch.torch_dtype_resolver","text":"<pre><code>torch_dtype_resolver(target: str) -&gt; dtype\n</code></pre> <p>Create a <code>torch.dtype</code> from its string representation.</p> <p>This resolver converts a string name to the corresponding PyTorch data type object. The string must match an attribute name in the torch module that represents a dtype (e.g., \"float32\", \"int64\").</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The target data type as a string. Must be a valid torch dtype attribute name such as \"float\", \"float32\", \"float64\", \"int32\", \"int64\", \"bool\", etc. The string should match the attribute name in torch (e.g., use \"float32\" not \"torch.float32\").</p> required <p>Returns:</p> Type Description <code>dtype</code> <p>The corresponding torch.dtype object.</p> <p>Raises:</p> Type Description <code>InterpolationResolutionError</code> <p>If the target string doesn't correspond to a valid torch dtype.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.torch.dtype:float}\"})\n&gt;&gt;&gt; conf.key\ntorch.float32\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.torch.dtype:int64}\"})\n&gt;&gt;&gt; conf.key\ntorch.int64\n</code></pre>"}]}