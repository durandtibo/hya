{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>hya</code> is a library of custom OmegaConf resolvers. <code>hya</code> is designed to be used with Hydra. The resolvers can be easily registered in your python project by adding the following lines:</p> <pre><code>from hya import register_resolvers\n\nregister_resolvers()\n</code></pre>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>hya</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>hya</code> to a new version will possibly break any code that was using the old version of <code>hya</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>hya</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install hya\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>hya</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'hya[all]'\n</code></pre> <p>This command also installed PyTorch. It is also possible to install the optional packages manually or to select the packages to install.</p> <pre><code>pip install hya torch\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>hya</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/hya.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate hya\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>hya</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"resolvers/","title":"Resolvers","text":"<p> This page describes some of the resolvers that are currently implemented.</p>"},{"location":"resolvers/#default","title":"Default","text":""},{"location":"resolvers/#hyaadd","title":"<code>hya.add</code>","text":"<p>This resolver adds the two inputs. The following config</p> <pre><code>value: ${hya.add:object1,object2}\n</code></pre> <p>is equivalent to:</p> <pre><code>value = object1 + object2\n</code></pre> <p>It is possible to add more than 2 inputs. The following config</p> <pre><code>value: ${hya.add:object1,object2,object3,object4}\n</code></pre> <p>is equivalent to:</p> <pre><code>value = object1 + object2 + object3 + object4\n</code></pre>"},{"location":"resolvers/#hyafloordiv","title":"<code>hya.floordiv</code>","text":"<p>This resolver computes the \"true\" division between two inputs. The following config</p> <pre><code>value: ${hya.floordiv:dividend,divisor}\n</code></pre> <p>is equivalent to:</p> <pre><code>value = dividend // divisor\n</code></pre>"},{"location":"resolvers/#hyaneg","title":"<code>hya.neg</code>","text":"<p>This resolver computes the negation of the input. The following config</p> <pre><code>value: ${hya.neg:number}\n</code></pre> <p>is equivalent to:</p> <pre><code>value = -number\n</code></pre>"},{"location":"resolvers/#hyamul","title":"<code>hya.mul</code>","text":"<p>This resolver multiplies the two inputs. The following config</p> <pre><code>value: ${hya.mul:object1,object2}\n</code></pre> <p>is equivalent to:</p> <pre><code>value = object1 * object2\n</code></pre> <p>It is possible to multiply more than 2 inputs. The following config</p> <pre><code>value: ${hya.mul:object1,object2,object3,object4}\n</code></pre> <p>is equivalent to:</p> <pre><code>value = object1 * object2 * object3 * object4\n</code></pre>"},{"location":"resolvers/#hyapow","title":"<code>hya.pow</code>","text":"<p>This resolver computes a value to a given power. The following config</p> <pre><code>value: ${hya.pow:fraction,exponent}\n</code></pre> <p>is equivalent to:</p> <pre><code>value = fraction**exponent\n</code></pre>"},{"location":"resolvers/#hyasqrt","title":"<code>hya.sqrt</code>","text":"<p>This resolver computes a squared root value of a number. The following config</p> <pre><code>value: ${hya.sqrt:number}\n</code></pre> <p>is equivalent to:</p> <pre><code>import math\n\nvalue = math.sqrt(number)\n</code></pre>"},{"location":"resolvers/#hyasha256","title":"<code>hya.sha256</code>","text":"<p>This resolver computes the SHA-256 hash of an object.</p>"},{"location":"resolvers/#hyasub","title":"<code>hya.sub</code>","text":"<p>This resolver subtracts the two inputs. The following config</p> <pre><code>value: ${hya.sub:object1,object2}\n</code></pre> <p>is equivalent to:</p> <pre><code>value = object1 - object2\n</code></pre>"},{"location":"resolvers/#hyato_path","title":"<code>hya.to_path</code>","text":"<p>This resolver transforms the input string to a <code>pathlib.Path</code>.</p>"},{"location":"resolvers/#hyatruediv","title":"<code>hya.truediv</code>","text":"<p>This resolver computes the \"true\" division between two inputs. The following config</p> <pre><code>value: ${hya.truediv:dividend,divisor}\n</code></pre> <p>is equivalent to:</p> <pre><code>value = dividend / divisor\n</code></pre>"},{"location":"resolvers/#pytorch","title":"PyTorch","text":"<p>You need to install PyTorch to use these resolvers.</p>"},{"location":"resolvers/#hyatorchtensor","title":"<code>hya.torch.tensor</code>","text":"<p>This resolver transforms the input to a <code>torch.Tensor</code>. The following config</p> <pre><code>value: ${hya.torch.tensor:[1,2,3]}\n</code></pre> <p>is equivalent to:</p> <pre><code>import torch\n\nvalue = torch.tensor([1, 2, 3])\n</code></pre>"},{"location":"refs/","title":"Main functions","text":""},{"location":"refs/#hya","title":"hya","text":"<p>Contain the main features of the <code>hya</code> package.</p>"},{"location":"refs/#hya.is_braceexpand_available","title":"hya.is_braceexpand_available","text":"<pre><code>is_braceexpand_available() -&gt; bool\n</code></pre> <p>Indicate if the braceexpand package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>braceexpand</code> is installed, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from hya.imports import is_braceexpand_available\n&gt;&gt;&gt; is_braceexpand_available()\n</code></pre>"},{"location":"refs/#hya.is_numpy_available","title":"hya.is_numpy_available","text":"<pre><code>is_numpy_available() -&gt; bool\n</code></pre> <p>Indicate if the numpy package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>numpy</code> is installed, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from hya.imports import is_numpy_available\n&gt;&gt;&gt; is_numpy_available()\n</code></pre>"},{"location":"refs/#hya.is_torch_available","title":"hya.is_torch_available","text":"<pre><code>is_torch_available() -&gt; bool\n</code></pre> <p>Indicate if the torch package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>torch</code> is installed, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from hya.imports import is_torch_available\n&gt;&gt;&gt; is_torch_available()\n</code></pre>"},{"location":"refs/#hya.register_resolvers","title":"hya.register_resolvers","text":"<pre><code>register_resolvers() -&gt; None\n</code></pre> <p>Register the default resolvers.</p> Example <pre><code>&gt;&gt;&gt; from hya import register_resolvers\n&gt;&gt;&gt; register_resolvers()\n</code></pre>"},{"location":"refs/registry/","title":"Registry","text":""},{"location":"refs/registry/#hya.registry","title":"hya.registry","text":"<p>Implement the resolver registry to easily register resolvers.</p>"},{"location":"refs/registry/#hya.registry.ResolverRegistry","title":"hya.registry.ResolverRegistry","text":"<p>Implement a resolver registry.</p> <p>This class manages a collection of resolver functions that can be registered with keys and later used with OmegaConf.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>dict[str, Callable[..., Any]] | None</code> <p>Optional initial state dictionary containing key-resolver pairs. If provided, a copy is made to prevent external modifications.</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; from hya.registry import ResolverRegistry\n&gt;&gt;&gt; registry = ResolverRegistry()\n&gt;&gt;&gt; @registry.register(\"my_key\")\n... def my_resolver(value):\n...     pass\n...\n</code></pre>"},{"location":"refs/registry/#hya.registry.ResolverRegistry.state","title":"hya.registry.ResolverRegistry.state  <code>property</code>","text":"<pre><code>state: dict[str, Callable[..., Any]]\n</code></pre> <p>The state of the registry.</p>"},{"location":"refs/registry/#hya.registry.ResolverRegistry.has_resolver","title":"hya.registry.ResolverRegistry.has_resolver","text":"<pre><code>has_resolver(key: str) -&gt; bool\n</code></pre> <p>Check if a resolver is explicitly registered for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a resolver is registered for this key,</p> <code>bool</code> <p>False otherwise</p> Example <pre><code>&gt;&gt;&gt; from hya.registry import ResolverRegistry\n&gt;&gt;&gt; registry = ResolverRegistry()\n&gt;&gt;&gt; @registry.register(\"my_key\")\n... def my_resolver(value):\n...     pass\n...\n&gt;&gt;&gt; registry.has_resolver(\"my_key\")\nTrue\n&gt;&gt;&gt; registry.has_resolver(\"missing\")\nFalse\n</code></pre>"},{"location":"refs/registry/#hya.registry.ResolverRegistry.register","title":"hya.registry.ResolverRegistry.register","text":"<pre><code>register(\n    key: str, exist_ok: bool = False\n) -&gt; Callable[[F], F]\n</code></pre> <p>Register a resolver to registry with the specified key.</p> <p>This method returns a decorator that can be used to register resolver functions.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key used to register the resolver. Must be unique unless exist_ok is True.</p> required <code>exist_ok</code> <code>bool</code> <p>If False, a RuntimeError is raised if you try to register a new resolver with an existing key. If True, the existing resolver will be overridden.</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[F], F]</code> <p>A decorator function that registers the resolver and returns it unchanged.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the resolver is not callable.</p> <code>RuntimeError</code> <p>If the key already exists and exist_ok is False.</p> Example <pre><code>&gt;&gt;&gt; from hya.registry import ResolverRegistry\n&gt;&gt;&gt; registry = ResolverRegistry()\n&gt;&gt;&gt; @registry.register(\"my_key\")\n... def my_resolver(value):\n...     return value * 2\n...\n&gt;&gt;&gt; my_resolver(5)\n10\n</code></pre>"},{"location":"refs/registry/#hya.registry.ResolverRegistry.register_resolvers","title":"hya.registry.ResolverRegistry.register_resolvers","text":"<pre><code>register_resolvers() -&gt; None\n</code></pre> <p>Register the resolvers to OmegaConf.</p> <p>This method iterates through all registered resolvers and registers them with OmegaConf if they haven't been registered already.</p> Example <pre><code>&gt;&gt;&gt; from hya.registry import ResolverRegistry\n&gt;&gt;&gt; registry = ResolverRegistry()\n&gt;&gt;&gt; @registry.register(\"multiply\")\n... def multiply_resolver(x, y):\n...     return x * y\n...\n&gt;&gt;&gt; registry.register_resolvers()\n</code></pre>"},{"location":"refs/registry/#hya.registry.get_default_registry","title":"hya.registry.get_default_registry","text":"<pre><code>get_default_registry() -&gt; ResolverRegistry\n</code></pre> <p>Get or create the default global resolver registry.</p> <p>Returns a singleton registry instance using a simple singleton pattern. The registry is initially empty and can be populated with custom resolvers.</p> <p>This function uses a singleton pattern to ensure the same registry instance is returned on subsequent calls, which is efficient and maintains consistency across an application.</p> <p>Returns:</p> Type Description <code>ResolverRegistry</code> <p>A ResolverRegistry instance</p> Notes <p>The singleton pattern means modifications to the returned registry affect all future calls to this function. If you need an isolated registry, create a new ResolverRegistry instance directly.</p> Example <pre><code>&gt;&gt;&gt; from hya.registry import get_default_registry\n&gt;&gt;&gt; registry = get_default_registry()\n&gt;&gt;&gt; @registry.register(\"my_key\")\n... def my_resolver(value):\n...     pass\n...\n</code></pre>"},{"location":"refs/registry/#hya.registry.register_resolvers","title":"hya.registry.register_resolvers","text":"<pre><code>register_resolvers() -&gt; None\n</code></pre> <p>Register the default resolvers.</p> Example <pre><code>&gt;&gt;&gt; from hya import register_resolvers\n&gt;&gt;&gt; register_resolvers()\n</code></pre>"},{"location":"refs/resolvers/","title":"Resolvers","text":""},{"location":"refs/resolvers/#native-resolvers","title":"Native resolvers","text":""},{"location":"refs/resolvers/#hya.resolvers","title":"hya.resolvers","text":"<p>Implement some resolvers using features from standard libraries.</p>"},{"location":"refs/resolvers/#hya.resolvers.add_resolver","title":"hya.resolvers.add_resolver","text":"<pre><code>add_resolver(*args: Any) -&gt; Any\n</code></pre> <p>Return the addition of several objects.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>The values to add.</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p><code>arg1 + arg2 + arg3 + ... + argN</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.add:1,2}\"})\n&gt;&gt;&gt; conf.key\n3\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.add:1,2,3,4}\"})\n&gt;&gt;&gt; conf.key\n10\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.asinh_resolver","title":"hya.resolvers.asinh_resolver","text":"<pre><code>asinh_resolver(number: float) -&gt; float\n</code></pre> <p>Return the inverse hyperbolic sine.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to transform.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The inverse hyperbolic sine of the input number.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.asinh:1}\"})\n&gt;&gt;&gt; conf.key\n0.881373...\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.ceildiv_resolver","title":"hya.resolvers.ceildiv_resolver","text":"<pre><code>ceildiv_resolver(dividend: float, divisor: float) -&gt; float\n</code></pre> <p>Return the ceiling division of two numbers.</p> <p>Parameters:</p> Name Type Description Default <code>dividend</code> <code>float</code> <p>The dividend.</p> required <code>divisor</code> <code>float</code> <p>The divisor.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The output of the ceiling division.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.ceildiv:11,4}\"})\n&gt;&gt;&gt; conf.key\n3\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.exp_resolver","title":"hya.resolvers.exp_resolver","text":"<pre><code>exp_resolver(number: float) -&gt; float\n</code></pre> <p>Return the exponential value of the input.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to transform.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The exponential value of the input.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.exp:0}\"})\n&gt;&gt;&gt; conf.key\n1.0\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.floordiv_resolver","title":"hya.resolvers.floordiv_resolver","text":"<pre><code>floordiv_resolver(dividend: float, divisor: float) -&gt; float\n</code></pre> <p>Return the floor division of two numbers.</p> <p>Parameters:</p> Name Type Description Default <code>dividend</code> <code>float</code> <p>The dividend.</p> required <code>divisor</code> <code>float</code> <p>The divisor.</p> required <p>Returns:</p> Type Description <code>float</code> <p><code>dividend // divisor</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.floordiv:11,4}\"})\n&gt;&gt;&gt; conf.key\n2\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.iter_join_resolver","title":"hya.resolvers.iter_join_resolver","text":"<pre><code>iter_join_resolver(\n    iterable: Iterable[Any], separator: str\n) -&gt; str\n</code></pre> <p>Convert all items in an iterable to a string and joins them into one string.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[Any]</code> <p>Any iterable object where all the returned values are strings or can be converted to string.</p> required <code>separator</code> <code>str</code> <p>The separator to use between the items.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated string.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.iter_join:[abc,2,def],-}\"})\n&gt;&gt;&gt; conf.key\nabc-2-def\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.len_resolver","title":"hya.resolvers.len_resolver","text":"<pre><code>len_resolver(obj: Any) -&gt; int\n</code></pre> <p>Return the length of an object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The length of the object.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.len:[1,2,3]}\"})\n&gt;&gt;&gt; conf.key\n3\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.log10_resolver","title":"hya.resolvers.log10_resolver","text":"<pre><code>log10_resolver(number: float) -&gt; float\n</code></pre> <p>Compute base 10 logarithm of the input value.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to transform.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The base 10 logarithm of the input value.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.log10:1}\"})\n&gt;&gt;&gt; conf.key\n0.0\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.log_resolver","title":"hya.resolvers.log_resolver","text":"<pre><code>log_resolver(number: float, base: float = e) -&gt; float\n</code></pre> <p>Compute logarithm of the input value to the given base.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to transform.</p> required <code>base</code> <code>float</code> <p>The base.</p> <code>e</code> <p>Returns:</p> Type Description <code>float</code> <p>The logarithm of the input value to the given base.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.log:1}\"})\n&gt;&gt;&gt; conf.key\n0.0\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.max_resolver","title":"hya.resolvers.max_resolver","text":"<pre><code>max_resolver(*args: Any) -&gt; Any\n</code></pre> <p>Return the maximum between multiple values.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>The values.</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p><code>max(arg1, arg2, arg3, ..., argN)</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.max:1,2,3}\"})\n&gt;&gt;&gt; conf.key\n3\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.min_resolver","title":"hya.resolvers.min_resolver","text":"<pre><code>min_resolver(*args: Any) -&gt; Any\n</code></pre> <p>Return the minimum between multiple values.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>The values.</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p><code>min(arg1, arg2, arg3, ..., argN)</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.min:1,2,3}\"})\n&gt;&gt;&gt; conf.key\n1\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.mul_resolver","title":"hya.resolvers.mul_resolver","text":"<pre><code>mul_resolver(*args: Any) -&gt; Any\n</code></pre> <p>Return the multiplication of several objects.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>The values to multiply.</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p><code>arg1 * arg2 * arg3 * ... * argN</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.mul:1,2}\"})\n&gt;&gt;&gt; conf.key\n2\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.mul:1,2,3}\"})\n&gt;&gt;&gt; conf.key\n6\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.neg_resolver","title":"hya.resolvers.neg_resolver","text":"<pre><code>neg_resolver(number: float) -&gt; float\n</code></pre> <p>Return the negation (<code>-number</code>).</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to transform.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The negated input number.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.neg:1}\"})\n&gt;&gt;&gt; conf.key\n-1\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.path_resolver","title":"hya.resolvers.path_resolver","text":"<pre><code>path_resolver(path: str) -&gt; Path\n</code></pre> <p>Return a path object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The target path.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path object.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.path:/my/path}\"})\n&gt;&gt;&gt; conf.key\nPosixPath('/my/path')\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.pi_resolver","title":"hya.resolvers.pi_resolver","text":"<pre><code>pi_resolver() -&gt; float\n</code></pre> <p>Return the value PI.</p> <p>Returns:</p> Type Description <code>float</code> <p>The value of PI.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.pi:}\"})\n&gt;&gt;&gt; conf.key\n3.14159...\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.pow_resolver","title":"hya.resolvers.pow_resolver","text":"<pre><code>pow_resolver(value: float, exponent: float) -&gt; float\n</code></pre> <p>Return a value to a given power.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value or base.</p> required <code>exponent</code> <code>float</code> <p>The exponent.</p> required <p>Returns:</p> Type Description <code>float</code> <p><code>x ** y</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.pow:2,3}\"})\n&gt;&gt;&gt; conf.key\n8\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.sha256_resolver","title":"hya.resolvers.sha256_resolver","text":"<pre><code>sha256_resolver(obj: Any) -&gt; str\n</code></pre> <p>Return the SHA-256 hash of the input object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to compute the SHA-256 hash.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The SHA-256 hash of the object.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.sha256:mystring}\"})\n&gt;&gt;&gt; conf.key\nbd3ff47540b31e62d4ca6b07794e5a886b0f655fc322730f26ecd65cc7dd5c90\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.sinh_resolver","title":"hya.resolvers.sinh_resolver","text":"<pre><code>sinh_resolver(number: float) -&gt; float\n</code></pre> <p>Return the hyperbolic sine.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to transform.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The hyperbolic sine of the input number.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.sinh:1}\"})\n&gt;&gt;&gt; conf.key\n1.175201...\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.sqrt_resolver","title":"hya.resolvers.sqrt_resolver","text":"<pre><code>sqrt_resolver(number: float) -&gt; float\n</code></pre> <p>Return the square root of a number.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>float</code> <p>The number to compute the square root.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The square root of the input number.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.sqrt:4}\"})\n&gt;&gt;&gt; conf.key\n2.0\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.sub_resolver","title":"hya.resolvers.sub_resolver","text":"<pre><code>sub_resolver(object1: Any, object2: Any) -&gt; Any\n</code></pre> <p>Return the subtraction of two objects.</p> <p>Parameters:</p> Name Type Description Default <code>object1</code> <code>Any</code> <p>The first object.</p> required <code>object2</code> <code>Any</code> <p>The second object.</p> required <p>Returns:</p> Type Description <code>Any</code> <p><code>object1 - object2</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.sub:3,1}\"})\n&gt;&gt;&gt; conf.key\n2\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.to_path_resolver","title":"hya.resolvers.to_path_resolver","text":"<pre><code>to_path_resolver(path: str) -&gt; Path\n</code></pre> <p>Return the input path into a <code>pathlib.Path</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to convert. This value should be compatible with <code>pathlib.Path</code>.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The converted path.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.to_path:/my/path}\"})\n&gt;&gt;&gt; conf.key\nPosixPath('/my/path')\n</code></pre>"},{"location":"refs/resolvers/#hya.resolvers.truediv_resolver","title":"hya.resolvers.truediv_resolver","text":"<pre><code>truediv_resolver(dividend: float, divisor: float) -&gt; float\n</code></pre> <p>Return the true division of two numbers.</p> <p>Parameters:</p> Name Type Description Default <code>dividend</code> <code>float</code> <p>The dividend.</p> required <code>divisor</code> <code>float</code> <p>The divisor.</p> required <p>Returns:</p> Type Description <code>float</code> <p><code>dividend / divisor</code></p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.truediv:1,2}\"})\n&gt;&gt;&gt; conf.key\n0.5\n</code></pre>"},{"location":"refs/resolvers/#optional-resolvers","title":"Optional resolvers","text":""},{"location":"refs/resolvers/#hya.braceexpand_","title":"hya.braceexpand_","text":"<p>Implement a braceexpand resolver.</p> <p>The resolver is registered only if <code>braceexpand</code> is available.</p>"},{"location":"refs/resolvers/#hya.braceexpand_.braceexpand_resolver","title":"hya.braceexpand_.braceexpand_resolver","text":"<pre><code>braceexpand_resolver(pattern: str) -&gt; Iterator[str]\n</code></pre> <p>Return an iterator from a brace expansion of pattern.</p> <p>Please check https://github.com/trendels/braceexpand for more information about the syntax.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Specifies the pattern of the brace expansion.</p> required <p>Returns:</p> Type Description <code>Iterator[str]</code> <p>The iterator resulting from brace expansion of pattern.</p>"},{"location":"refs/resolvers/#hya.torch_","title":"hya.torch_","text":"<p>Implement PyTorch resolvers.</p> <p>The resolvers are registered only if <code>torch</code> is available.</p>"},{"location":"refs/resolvers/#hya.torch_.get_dtypes","title":"hya.torch_.get_dtypes","text":"<pre><code>get_dtypes() -&gt; set[dtype]\n</code></pre> <p>Get all the data types.</p> <p>Returns:</p> Type Description <code>set[dtype]</code> <p>The data types.</p>"},{"location":"refs/resolvers/#hya.torch_.to_tensor_resolver","title":"hya.torch_.to_tensor_resolver","text":"<pre><code>to_tensor_resolver(data: Any) -&gt; Tensor\n</code></pre> <p>Implement a resolver to transform the input to a <code>torch.Tensor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Specifies the data to transform in <code>torch.Tensor</code>. This value should be compatible with <code>torch.tensor</code></p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The input in a <code>torch.Tensor</code> object.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.torch.tensor:[1,2,3,4,5]}\"})\n&gt;&gt;&gt; conf.key\ntensor([1, 2, 3, 4, 5])\n</code></pre>"},{"location":"refs/resolvers/#hya.torch_.torch_dtype_resolver","title":"hya.torch_.torch_dtype_resolver","text":"<pre><code>torch_dtype_resolver(target: str) -&gt; dtype\n</code></pre> <p>Implement a resolver to create a <code>torch.dtype</code> from its string representation.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>Specifies the target data type.</p> required <p>Returns:</p> Type Description <code>dtype</code> <p>The data type.</p> Example <pre><code>&gt;&gt;&gt; import hya\n&gt;&gt;&gt; from omegaconf import OmegaConf\n&gt;&gt;&gt; hya.register_resolvers()\n&gt;&gt;&gt; conf = OmegaConf.create({\"key\": \"${hya.torch.dtype:float}\"})\n&gt;&gt;&gt; conf.key\ntorch.float32\n</code></pre>"}]}